From f02ebd4f19ba05577c6f49658afc46ae6defaada Mon Sep 17 00:00:00 2001
From: dyphire <qimoge@gmail.com>
Date: Sun, 10 Sep 2023 22:19:23 +0800
Subject: [PATCH] avformat/spdifenc: handle long TrueHD input_timing gaps

Some TrueHD streams contain frames that have very long gaps in
input_timing fields, while output_timing remains constant-rate. These
are likely due to encoding discontinuities of some sort as the TrueHD
substream terminator marker is observed before the gap.

Such frames trigger a sanity check in the current code - however, such
gaps are valid.

The gaps require us to insert many IEC 61937 bursts worth of MAT padding
into the output. To facilitate that, add a mechanism in
spdif_write_packet() to allow writing out multiple bursts per AVPacket,
and use that in spdif_header_truehd() to write out any full bursts that
do not yet contain any actual audio data from the current AVPacket.

Modify the sanity check to allow up to 50 MAT frames full of padding.
---
 libavformat/spdifenc.c | 67 ++++++++++++++++++++++++++++++++++--------
 1 file changed, 54 insertions(+), 13 deletions(-)

diff --git a/libavformat/spdifenc.c b/libavformat/spdifenc.c
index ca38674626..93db9a04b2 100644
--- a/libavformat/spdifenc.c
+++ b/libavformat/spdifenc.c
@@ -69,18 +69,21 @@ typedef struct IEC61937Context {
 
     int use_preamble;               ///< preamble enabled (disabled for exactly pre-padded DTS)
     int extra_bswap;                ///< extra bswap for payload (for LE DTS => standard BE DTS)
+    int more_bursts_needed;         ///< more bursts needed for the same AVPacket
 
-    uint8_t *hd_buf[2];             ///< allocated buffers to concatenate hd audio frames
+    uint8_t *hd_buf[3];             ///< allocated buffers to concatenate hd audio frames
     int hd_buf_size;                ///< size of the hd audio buffer (eac3, dts4)
     int hd_buf_count;               ///< number of frames in the hd audio buffer (eac3)
     int hd_buf_filled;              ///< amount of bytes in the hd audio buffer (eac3, truehd)
     int hd_buf_idx;                 ///< active hd buffer index (truehd)
+    int hd_buf_sent_idx;            ///< last sent hd buffer index (truehd)
 
     int dtshd_skip;                 ///< counter used for skipping DTS-HD frames
 
     uint16_t truehd_prev_time;      ///< input_timing from the last frame
     int truehd_prev_size;           ///< previous frame size in bytes, including any MAT codes
     int truehd_samples_per_frame;   ///< samples per frame for padding calculation
+    int truehd_padding_remaining;   ///< amount of padding still needed before data
 
     /* AVOptions: */
     int dtshd_rate;
@@ -453,7 +456,11 @@ static int spdif_header_truehd(AVFormatContext *s, AVPacket *pkt)
         return AVERROR_INVALIDDATA;
 
     input_timing = AV_RB16(pkt->data + 2);
-    if (ctx->truehd_prev_size) {
+    if (ctx->truehd_padding_remaining) {
+         /* padding was calculated on previous call and some still remains */
+         padding_remaining = ctx->truehd_padding_remaining;
+
+     } else if (ctx->truehd_prev_size) {
         uint16_t delta_samples = input_timing - ctx->truehd_prev_time;
         /*
          * One multiple-of-48kHz frame is 1/1200 sec and the IEC 61937 rate
@@ -473,9 +480,12 @@ static int spdif_header_truehd(AVFormatContext *s, AVPacket *pkt)
                delta_samples, delta_bytes);
 
         /* sanity check */
-        if (padding_remaining < 0 || padding_remaining >= MAT_FRAME_SIZE / 2) {
-            avpriv_request_sample(s, "Unusual frame timing: %"PRIu16" => %"PRIu16", %d samples/frame",
+        if (padding_remaining < 0 || padding_remaining >= MAT_PKT_OFFSET * 50) {
+            avpriv_request_sample(s, "Unusual frame timing (%"PRIu16" => %"PRIu16", %d samples/frame)",
                                   ctx->truehd_prev_time, input_timing, ctx->truehd_samples_per_frame);
+            ctx->hd_buf_idx = 0;
+            ctx->hd_buf_sent_idx = 0;
+            ctx->hd_buf_filled = 0;
             padding_remaining = 0;
         }
     }
@@ -505,7 +515,7 @@ static int spdif_header_truehd(AVFormatContext *s, AVPacket *pkt)
                 /* this was the last code, move to the next MAT frame */
                 have_pkt = 1;
                 ctx->out_buf = hd_buf;
-                ctx->hd_buf_idx ^= 1;
+                ctx->hd_buf_idx = (ctx->hd_buf_idx + 1) % 3;
                 hd_buf = ctx->hd_buf[ctx->hd_buf_idx];
                 ctx->hd_buf_filled = 0;
 
@@ -523,6 +533,15 @@ static int spdif_header_truehd(AVFormatContext *s, AVPacket *pkt)
             /* count the remainder of the code as part of frame size */
             if (code_len_remaining)
                 total_frame_size += code_len_remaining;
+
+                if (have_pkt && padding_remaining) {
+                 /*
+                  * We already have a full burst but padding still remains,
+                  * write out the current burst and ask us to be called again
+                  * via ctx->more_bursts_needed to avoid filling our buffers.
+                  */
+                 break;
+             }
         }
 
         if (padding_remaining) {
@@ -550,19 +569,28 @@ static int spdif_header_truehd(AVFormatContext *s, AVPacket *pkt)
 
     ctx->truehd_prev_size = total_frame_size;
     ctx->truehd_prev_time = input_timing;
+    ctx->truehd_padding_remaining = padding_remaining;
 
-    av_log(s, AV_LOG_TRACE, "TrueHD frame inserted, total size %d, buffer position %d\n",
-           total_frame_size, ctx->hd_buf_filled);
+    if (padding_remaining)
+         av_log(s, AV_LOG_TRACE, "TrueHD frame not yet inserted, %d bytes more padding needed\n",
+                padding_remaining);
+     else
+         av_log(s, AV_LOG_TRACE, "TrueHD frame inserted, total size %d, buffer position %d\n",
+                total_frame_size, ctx->hd_buf_filled);
 
-    if (!have_pkt) {
+    if (ctx->hd_buf_sent_idx == ctx->hd_buf_idx) {
         ctx->pkt_offset = 0;
         return 0;
     }
 
-    ctx->data_type   = IEC61937_TRUEHD;
-    ctx->pkt_offset  = MAT_PKT_OFFSET;
-    ctx->out_bytes   = MAT_FRAME_SIZE;
-    ctx->length_code = MAT_FRAME_SIZE;
+    ctx->out_buf          = ctx->hd_buf[ctx->hd_buf_sent_idx];
+    ctx->hd_buf_sent_idx = (ctx->hd_buf_sent_idx + 1) % 3;
+    ctx->data_type        = IEC61937_TRUEHD;
+    ctx->pkt_offset       = MAT_PKT_OFFSET;
+    ctx->out_bytes        = MAT_FRAME_SIZE;
+    ctx->length_code      = MAT_FRAME_SIZE;
+    if (padding_remaining)
+         ctx->more_bursts_needed = 1;
     return 0;
 }
 
@@ -622,7 +650,7 @@ static av_always_inline void spdif_put_16(IEC61937Context *ctx,
         avio_wl16(pb, val);
 }
 
-static int spdif_write_packet(struct AVFormatContext *s, AVPacket *pkt)
+static int spdif_write_burst(AVFormatContext *s, AVPacket *pkt)
 {
     IEC61937Context *ctx = s->priv_data;
     int ret, padding;
@@ -632,6 +660,7 @@ static int spdif_write_packet(struct AVFormatContext *s, AVPacket *pkt)
     ctx->length_code = FFALIGN(pkt->size, 2) << 3;
     ctx->use_preamble = 1;
     ctx->extra_bswap = 0;
+    ctx->more_bursts_needed = 0;
 
     ret = ctx->header_info(s, pkt);
     if (ret < 0)
@@ -674,6 +703,18 @@ static int spdif_write_packet(struct AVFormatContext *s, AVPacket *pkt)
     return 0;
 }
 
+static int spdif_write_packet(AVFormatContext *s, AVPacket *pkt)
+{
+     IEC61937Context *ctx = s->priv_data;
+     int ret = 0;
+
+     ctx->more_bursts_needed = 1;
+     while (ctx->more_bursts_needed && ret == 0)
+         ret = spdif_write_burst(s, pkt);
+
+     return ret;
+}
+
 const FFOutputFormat ff_spdif_muxer = {
     .p.name            = "spdif",
     .p.long_name       = NULL_IF_CONFIG_SMALL("IEC 61937 (used on S/PDIF - IEC958)"),
-- 
2.41.0.windows.3

